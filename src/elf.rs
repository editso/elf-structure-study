#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(unused)]

use std::ffi::c_uchar;

pub type Elf32_Half = u16;
pub type Elf32_Addr = u32;
pub type Elf32_Off = u32;
pub type Elf32_Sword = i32;
pub type Elf32_Word = u32;

/// 下面是对ELF文件头结构字段相关描述
///   1. 位于文件的最开始处, 包含整个文件的结构信息

/// 下面是对`e_ident`数组字段相索引关值描述
/// 文件标志
pub const EI_MAG0: usize = 0;
/// 文件标志
pub const EI_MAG1: usize = 1;
/// 文件标志
pub const EI_MAG2: usize = 2;
/// 文件标志
pub const EI_MAG3: usize = 3;
/// 文件类别
pub const EI_CLASS: usize = 4;
/// 编码格式
pub const EI_DATA: usize = 5;
/// 文件版本
pub const EI_VERSION: usize = 6;
/// 补齐字节开始位置
pub const EI_PAD: usize = 7;
/// e_ident[]数组大小
pub const EI_NIDENT: usize = 16;
/// 下面是EI_VERSION索引相关含义
pub const EV_CURRENT: u8 = 1;

/// 下面是对`e_class`字段相关值描述
/// 下面是ELF_CLASS缩影中的值相关含义
/// 非法目标文件
pub const ELF_CLASS_NONE: u8 = 0;
/// 32位目标文件
pub const ELF_CLASS_32: u8 = 1;
/// 64位目标文件
pub const ELF_CLASS_64: u8 = 2;

/// 下面是对`e_data`字段相关值描述
/// 下面是ELF_DATA索引值相关含义
/// 非法编码格式
pub const ELF_DATA_NONE: u8 = 0;
/// LSB编码(小头编码)
pub const ELF_DATA_2LSB: u8 = 1;
/// MSB编码(大头编码)
pub const ELF_DATA_2MSB: u8 = 2;

/// 下面是对`e_type`字段相关值描述
/// 未知文件类型
pub const ET_NONE: Elf32_Half = 0;
/// 可重定位文件
pub const ET_REL: Elf32_Half = 1;
/// 可执行文件
pub const ET_EXECL: Elf32_Half = 2;
/// 动态链接库文件
pub const ET_DYN: Elf32_Half = 3;
/// Core文件
pub const ET_CORE: Elf32_Half = 4;
/// 特定处理器文件扩展下边界
pub const ET_LOPROC: Elf32_Half = 0xff00;
/// 特定处理器文件扩展上边界
pub const ET_HIPROC: Elf32_Half = 0xffff;

/// 下面是 对`e_machine`字段相关值描述
/// 未知体系结构
pub const EM_NONE: Elf32_Half = 0;
/// AT&T WE 32100
pub const EM_M32: Elf32_Half = 1;
/// SPARC
pub const EM_SPARC: Elf32_Half = 2;
/// Intel Architecture
pub const EM_386: Elf32_Half = 3;
/// Motorola 68000
pub const EM_68K: Elf32_Half = 4;
/// Motorola 88000
pub const EM_88K: Elf32_Half = 5;
/// Intel 80860
pub const EM_860: Elf32_Half = 7;
/// MIPS RS3000 Big-Endian
pub const EM_MIPS: Elf32_Half = 8;
/// MIPS RS4000 Big-Endian
pub const EM_MIPS_RS4_BE: Elf32_Half = 10;
/// 保留的 11 ~ 16
pub const RESERVED: Elf32_Half = 11;

#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Ehdr {
    /// 最开始处这个16个字节含有ELF文件识别标志
    /// EI_MAG0 ~ EI_MAG3: 4个字节的内容被称为魔数
    ///   用于表示这是一个ELF文件, 这四个字节存放的内容是固定的
    ///   EL_MAG0: 0x7f
    ///   EL_MAG1: 'E'
    ///   EL_MAG2: 'L'
    ///   EL_MAG3: 'F'
    /// EL_CLASS: 接下来的一个字节指明文件的类型
    ///   ELFCLASSNONE
    ///   ELF_CLASS_32
    ///   ELF_CLASS_64
    /// EL_DATA: 指明了目标文件中的数据编码格式
    ///   ELF_DATA_NONE
    ///   ELF_DATA_2LSB
    ///   ELF_DATA_2MSB
    /// EL_VERSION: 指明ELF文件头版本, 目前这个版本好是 1
    /// EL_PAD: e_ident[EL_PAD] ~ e_ident[EL_NIDENT - 1] 之间的9个字节目前暂时不使用
    ///   留做以后扩展
    pub e_ident: [c_uchar; EI_NIDENT],
    /// 该字段表明目标文件属于哪种类型
    pub e_type: Elf32_Half,
    /// 该字段用于指定文件适用的处理器体系结构
    /// 对于`Intel`架构处理器,取固定值EM_386
    pub e_machine: Elf32_Half,
    /// 指明目标文件的版本 当前最新版本号是`1` `EV_CURRENT`
    pub e_version: Elf32_Word,
    /// 程序入口的虚拟地址, 也就是文件被加载到进程空间后, 入口程序在进程地址空间的地址
    /// 对于可执行文件来说, 但`ELF`文件加载之后, 程序将会从这里开始运行, 对于其他文件来说, 这个值应该是`0`
    pub e_entry: Elf32_Addr,
    /// 此字段指明程序头表, 开始处在文件中的偏移量, 如过没有程序表头, 该值应设为 `0`
    pub e_phoff: Elf32_Off,
    /// 此字段指明节头表, 开始处在文件的偏移量, 如过没有节头表, 该值应设为 `0`
    pub e_shoff: Elf32_Off,
    /// 此字段含有处理器特定的标志位
    /// 对于`Intel`来说, 它没有任何标志位, 所以e_flags应该为 `0`
    pub e_flags: Elf32_Word,
    /// 此字段表明 `ELF` 文件头的大小, 以字节为单位
    pub e_ehsize: Elf32_Half,
    /// 此字段表明程序头表中每一个表项的大小, 以字节为单位
    pub e_phentsize: Elf32_Half,
    /// 此字段表明程序头表总共有多少个表项, 如过一个目标文件没有程序头表, 该值应设为`0`
    pub e_phnum: Elf32_Half,
    /// 此字段表明在节头表每一个表项的大小, 以字节为单位
    pub e_shentsize: Elf32_Half,
    /// 此字段表明节头表总共有多少个表项, 如何一个目标文件中没有节头标, 该值应设为`0`
    pub e_shnum: Elf32_Half,
    /// 节头表中与节名字相对应的表项索引, 如过文件没有节名字表, 此值应该设置为 SHN_UNDEF
    pub e_shstrndx: Elf32_Half,
}

/// 节
/// 在目标文件中可以包含很多节, 所有这些节都登记在一张称为节头表的数组里, 节头表的每一个表项是一个ELf32_Shdr结构, 通过每一个表项可以定位到对应的节

/// 某些表项的索引值被保留, 有特殊含义, ELF文件的节头表中不会出现索引值为一下值:
/// 除`0`以外 节表头中所有保留的索引值都位于 SHN_LORESERVE ~ SHN_HIRESERVE 范围字节, 与 索引值 `0` 不同, 这些大数值索引并不出现在节头标中
/// 通常, 目标文件含有众多的节, 节区是文件中最大的部分, 它们需要满足下面情况
///   目标文件中的每一个节一定对应有一个节头, 节头中有对节的描述信息, 但有的节头可以没有对应的节, 而是一个空的头
///   每一个节所占用的空间是连续的
///   各个节之间不能相互重叠
///   在目标文件中, 节与节之间可能会存在一些多余的节, 这些字节不属于任何节
/// 该值被定义为`0`, 是一个未定义的保留值, 但在节头表中的索引还是会从0开始
pub const SHN_UNDEF: Elf32_Half = 0;
/// 被保留索引号区间下限
pub const SHN_LORESERVE: Elf32_Half = 0xff00;
/// 为处理器定制节所保留的索引号区间下限
pub const SHN_LOPROC: Elf32_Half = 0xff00;
/// 为处理器定制所保留的索引号区间的上限
pub const SHN_HIPROC: Elf32_Half = 0xff1f;
/// 此节所定义的符号有绝对值, 这个值不会因重定位而改变
pub const SHN_ABS: Elf32_Half = 0xfff1;
/// 此节中所定义的符号是公共的, 比如FORTRAN COMMON符号或者未分配的C外部变量
pub const SHN_COMMON: Elf32_Half = 0xfff2;
/// 被保留索引区间的上限
pub const SHN_HIRESERVE: Elf32_Half = 0xffff;

/// 下面是对`sh_type`字段值相关描述
/// 表明本节是一个无效的(非活动的)节头, 他也没有对应的节, 本节头中的其它成员的值也都是没有意义的
pub const SHT_NULL: Elf32_Word = 0;
/// 表明本节所含有的信息是由程序定义的, 本节内容的格式和含义都由程序来决定
pub const SHT_PROGBITS: Elf32_Word = 1;
/// SHT_SYMTAB && SHT_DYNSYM
/// 这两类节都含有符号表, 目前, 目标文件中最多只能各包含一个这两种节
/// 一般来说, SHI_SYMTAB提供的符号用于在创建目标文件的时候编辑连接, 在运行期间也有可能会用于动态链接, SHT_SYMTAB包含完整的符号表
/// 它往往会包含很多在运行期间(动态连接)用不到符号, 所以一个目标文件可以再有一个SHT_DYNNSYM节, 它含有一个较小的符号表, 专门用于动态连接
pub const SHT_SYMTAB: Elf32_Word = 2;
/// 此值表明本节是字符串表, 目标文件中可以包含多个字符串表节
pub const SHT_STRTAB: Elf32_Word = 3;
/// 表明是一个重定位节, 含有带明确加数(addend)的重定位项, 对于32为类型的目标文件来说
/// 这个加数就是Elf32_Rela, 一个目标文件可能含有多个重定位节
pub const SHT_RELA: Elf32_Word = 4;
/// 此值表明本节包含一张哈希表, 所有参与动态链接的目标文件都必须要包含一张哈希表
/// 目标一个目标文件中最多只能有一个哈希表
pub const SHT_HASH: Elf32_Word = 5;
/// 表明本节包含的是动态连接信息
/// 目前, 一个目标文件中最多只能有一个SHT_DYNMIC节
pub const SHT_DYNAMIC: Elf32_Word = 6;
/// 表明本节包含的信息可用于以某种方式来标记本文件
pub const SHT_NOTE: Elf32_Word = 7;
/// 表明这一节是空的, 并不占用实际空间
pub const SHT_NOBITS: Elf32_Word = 8;
/// 表明本节是一个重定位节, 含有带明确家数的重定位项
/// 对于32为类型来说, 这个家数就是Elf32_Rel, 一个目标文件可能含有多个重定位
pub const SHT_REL: Elf32_Word = 9;
/// 此值是一个保留值, 暂未指定语义
pub const SHT_SHLIB: Elf32_Word = 10;
/// 此值表明本节是符号表, 与SHT_SYMTAB同义
pub const SHT_DYNSYM: Elf32_Word = 11;
/// 为特殊处理器保留的节类型索引值下边界
pub const SHT_LOPROC: Elf32_Word = 0x70000000;
/// 为特殊处理器保留的节类型索引值的上边界
pub const SHT_HIPROC: Elf32_Word = 0x7fffffff;
/// 为应用程序保留节类型索引值的下边界
pub const SHT_LOUSER: Elf32_Word = 0x80000000;
/// 为应用程序保留节类型索引值的下边界
pub const SHT_HIUSER: Elf32_Word = 0xffffffff;

/// 下面是对`sh_flags`字段中值的描述
/// 如过此标志被设置, 表明本节所包含的内容在进程运行过程中是可写的
pub const SHF_WRITE: Elf32_Word = 0x1;
/// 如过此标志被设置, 表示本节内容在进程运行过程中 要占用内存单元
/// 并不是所有节都会占用实际的内存, 有一些起控制节作用的节, 在目标文件映射到进程空间时,并不需要占用内存
pub const SHF_ALLOC: Elf32_Word = 0x2;
/// 表示此节内容是指令代码
pub const SHF_EXECINSTR: Elf32_Word = 0x4;
/// 保留做特殊处理器扩展用的
pub const SHF_MASKPROC: Elf32_Word = 0xf0000000;

/// 节头 (Section Header)
#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Shdr {
    /// 本节的名字, 整个名字的字符串并不存储在这里, 它仅是一个索引号, 指向 字符串表节中的某个位置, 那里存储了一个以`\0`结尾的字符串
    pub sh_name: Elf32_Word,
    /// 本节的类型
    pub sh_type: Elf32_Word,
    /// 本节的一些属性, 由一系列标志位组成, 各个比特定义了节的不同属性
    /// 但某种属性被设置时, 相应的标志位被设为`1`反之`0` 未定义的标志位全部置为`0`
    pub sh_flags: Elf32_Word,
    /// 如过本节的内容需要映射到内存进程空间中去, 此成员指定映射的启始地址, 如过不需要映射, 此值为`0`
    pub sh_addr: Elf32_Addr,
    /// 本节所在位置, 该值是节的第一个字节在文件中的位置, 即相对于文件开头的偏移量, 单位是字节,
    /// 如过该节的类型为`SHT_NOBITS`的话, 表明这一节的内容是空的, 节并不占用实际的空间, 这时`sh_offset`只代表一个逻辑上的位置, 并不代表实际的内容
    pub sh_offset: Elf32_Off,
    /// 节的大小, 单位是字节, 如过该类型为 `SHT_NOBITS` 此值仍然可以能为非零, 但没有实际意义
    pub sh_size: Elf32_Word,
    /// 此值是一个索引值, 指向节头表中本节所对应的位置, 根据节的类型不同, 本成员的意义也有说不同
    /// sh_type: SHT_DYNAMIC
    ///   sh_link: 本节项目中的字符串表在节头表中相应的索引值
    ///   sh_info: 0
    /// sh_type: SHT_HASH
    ///   sh_link: 本节中哈希表的符号表在节头表中相应的索引值
    ///   sh_info: 0
    /// sh_type: SHT_REL / SHT_RELA
    ///   sh_link: 相应符号表在节头表中的索引值
    ///   sh_info: 本从重定位节所应用到目标节在节头表中的索引值
    /// sh_type: SH_SYMTAB / SH_DYNSYM
    ///   sh_link: 相关字符串表的节索引
    ///   sh_info: 符号表中最后一个本地符号索引值加 1
    pub sh_link: Elf32_Word,
    /// 含有此节的附加信息, sh_link 和 sh_info 含有特殊的信息
    pub sh_info: Elf32_Word,
    /// 对齐, 即能被sh_addralign整除的数, 目前sh_addralign只能取0, 1或者2的正倍数, 如果该值位0或1, 表明本节没有字节对齐约束
    pub sh_addralign: Elf32_Word,
    /// 有一些节的内容是一张表, 每一个表项的大小是固定的, 比如符号表, 对于这种表来说, 本成员制定其一个表的大小, 如过此值位0则表明本节内容不是这种表格
    /// 其它的节类型值是保留未用的
    pub sh_entsize: Elf32_Word,
}

/// 符号表
/// 目标文件中的符号表, 说包含的信息用于定位和重定位程序中的符号定义和引用
/// 目标文件的其它部分通过一个符号在这个表中的索引值来使用该符号, 索引从0开始计数, 但值为0的表项 (即第一项) 并没有实际意义, 它表示未定义的符号
/// 这里用常量STN_UNDEF来表示未定义的符号

/// 符号绑定
/// 在符号表中，不同属性的符号所在位置也有不同，本地符号(STB_LOCAL)
/// 排在前面，全局符号(STB_GLOBAL/STB_WEAK)排在后面

/// 表明本符号是一个本地符号, 它只出现在本文件中
/// 在本文件外该符号无效, 所以在不同的文件中可以定义相同的符号名
/// 它们之间不会相互影响
pub const STB_LOCAL: u8 = 0;
/// 表明本符号是一个全局符号, 当有多个文件被连接在一起时, 在所有文件中该符号都是可见的
/// 正常情况下, 在一个文件中定义的全局符号, 一定是在其他文件中需要被引用, 否则无需定义为全局
pub const STB_GLOBAL: u8 = 1;
/// 类似于全局符号, 但是相对于STB_GLOBAL 他们的优先级更低
/// 全局符号和弱符号在有两方面区别:
///   1. 当连接编辑器把若干个可重定位目标文件连接起来时, 同名的STB_GLOBAL符号不允许出现多次
///   而如果在一个目标文件中已经定义了一个全局符号, 当一个同名的弱符号出现时, 并不会发生错误
///   连接编辑器会以全局符号为准, 忽略弱符号, 与全局符号类似, 如果已经存在一个公用符号, 即st_shndx为SHN_COMMON值的符号
///   当同一个弱符号出现时, 也不会发生错误, 连接编辑器会以公用符号为准, 忽略弱符号
///   2. 在查找符号定义哦时, 连接编辑器可能会搜索存档的库文件, 如果是查找全局符号, 连接编辑器会提取包含该未定义的全局符号的存档成员, 存档成员可能是一个全局的符号
///   也可能是是弱符号, 而如果是查找弱符号, 连接编辑器不回去提取存档成员, 为解析的弱符号值为0
pub const STB_WEAK: u8 = 2;

/// STB_LOPROC ~ STB_HIPROC: 为特殊处理器保留的属性区间
pub const STB_LOPROC: u8 = 13;
pub const STB_HIPPOC: u8 = 15;

#[macro_export]
macro_rules! ELF32_ST_BIND {
    ($v: expr) => {
        (($v) >> 4)
    };
}

/// 符号类型

/// 类型未指定
pub const STT_NOTYPE: u8 = 0;
/// 是一个数据对象, 比如变量, 数组等
pub const STT_OBJECT: u8 = 1;
/// 本符号是一个函数, 或者其他的可执行代码, 函数符号在共享目标文件中有特殊的意义,
/// 当另外一个目标文件引用一个共享目标文件中的函数符号时, 连接编辑器为被引用符号自动创建一个连接表项
/// 非STT_FUNC类型的共享符号不会通过这种连接表项被自动引用
pub const STT_FUNC: u8 = 2;
/// 本符号与一个节相关联, 用于重定位, 通常具有STB_LOCAL属性
pub const STT_SECTION: u8 = 3;
/// 本符号是一个文件符号, 它具有STB_LOCAL属性, 它的节索引值是SHN_ABS, 在符号表中存在本类符号的话
/// 它会出现在所有STB_LOCAL类符号的前部
pub const STT_FILE: u8 = 4;
/// STT_LOPROC ~ STT_HIPROC: 这一区间的符号类型为特殊处理器保留
pub const STT_LOPROC: u8 = 5;
pub const STT_HIPROC: u8 = 15;

#[macro_export]
macro_rules! ELF32_ST_TYPE {
    ($v: expr) => {
        (($v) & 0xf)
    };
}

#[macro_export]
macro_rules! ELF32_ST_INFO {
    ($b: expr, $t: expr) => {
        ((($b) << 4) + (($t) & 0xf))
    };
}

#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Sym {
    /// 符号表的名字, 但它并不是一个字符串, 而是一个指向字符串表的索引值
    /// 在字符串表中对应位置上的字符串就是该符号名字的实际文本, 如过此值为非0
    /// 它代表符号名字在字符串表中的索引值, 如过此值为0, 那么此符号无名字
    pub st_name: Elf32_Word,
    /// 符号的值, 这个值其实没有固定的类型, 它可能代表一个数值, 也可以是一个地址
    /// 具体是什么要看上下文:
    ///   在重定位文件中, 如过符号对应的节索引值是 SHN_COMMON,  st_value 值是这个节内容字节对齐数
    ///   在重定位, 如果符号是已定义的, 那么它的值是该符号的启示地址在其节中的偏移量, 而其所在节的索引由st_shndx给出
    ///   在可执行文件和共享文件中, st_value不再是一个节内的偏移量, 而是一个虚拟地址, 直接指向符号所在的内存位置, 这种情况下, st_shndx就不在需要了
    /// 综合以上三点可知, 在不同的目标文件中, st_value的值多少有所不同, 这样的设计是为了在各种类型的文件中更有效的访问数据
    /// 如过一个可执行文件中含有一个函数引用, 而这个函数定义在一个共享目标文件中, 那么在可执行文件中, 针对那个共享目标文件的符号表应该含有这个函数的符号
    /// 符号表的我st_shndx成员值为SHN_UNDEF, 这就告诉了动态连接器, 这个函数的符号定义并不在可执行文件中, 如过已经在可执行文件中给这个符号申请了一个函数连接表项
    /// 而起符号表项的st_value成员不是0, 那么st_value值就将函数连接表项中第一条指令的地址, 否则st_value成员是0, 这个函数连接表项地址被动态连接器用来解析函数地址
    pub st_value: Elf32_Addr,
    /// 符号的大小, 各种符号的大小各不相同, 比如一个对象的大小就是它实际占用的字节数, 如过一个符号的大小为0或者大小未知, 则这个值为0
    pub st_size: Elf32_Word,
    /// 符号的类型和属性, 由一些列的比特位构成, 标识了 符号绑定 符号类型 和 符号信息 三种属性
    ///   ELF32_ST_BIND(i) ((i) >> 4)
    ///   ELF32_ST_TYPE(i) ((i) & 0xf)
    ///   ELF32_ST_INFO(b, t) (((b) << 4) + ((t) & 0xf))
    pub st_info: c_uchar,
    /// 本数据成员目前暂未使用，在目标文件中一律赋值为0。
    pub st_other: c_uchar,
    /// 任何一个符号表项的定义都与某一个节相联系, 因为符号是为节定而定义的, 在节中被引用吗本数据成员指明了相关联的节
    /// 本数据成员是一个索引值, 它指向相关联的节在节头表中的索引, 在重定位过程中, 节的位置会改变, 本书就成员的的值也会随之改变, 继续指向节的新位置
    /// 但本数据成员指向下面三种特殊节索引值时, 本符号具有如下特别意义
    ///   SHN_ABS: 值是绝对的, 具有常量性, 在重定位过程中, 此值不需要改变
    ///   SHN_COMMON: 本符号所关联是一个还没有分配的公共节, 本符号的值规定了其内容的字节对齐规则, 与sh_addralign相似
    ///   也就是说, 连接器会为本符号分配存储空间, 而且起始地址是向st_value对齐的, 本符号的值指明了要分配的字节数
    ///   SHN_UNDEF: 当符号指向第1节时, 表明本符号在当前目标文件未定义, 在连接过程中, 连接器会找到此符号被定义的文件, 并把
    ///   这些文件连接在一起, 本文件中对该符号的引用会被连接到实际的定义上去
    pub st_shndx: Elf32_Half,
}

/// 重定位
/// 重定位是把符号引用与符号定义连接在一起的过程, 比如, 当程序调用一个函数时, 将从当前运行的指令跳转到一个新的指令地址去执行
/// 在编写程序的时候, 我们只需指明说要调用的函数名(即符号引用), 在重点位过程中, 函数名会与实际的函数所在地址(即符号定义)联系起来,
/// 使程序知道应该跳转到那里去, 重定位必须知道如何修改其所包含的 ‘节’ 内容 在构建可执行文件或共享目标文件的时候, 把节中的符号引用
/// 换成这些符号在进程空间中的虚拟地址, 包含这些转换信息的数据 也是重定位项

/// ELF32_Rela与Elf32_Rel在结构上只有一处不同, 就是前者有r_addend
/// Elf32_Rela中是用r_addend显式地指出加数, 而对Elf32_Rel来说, 加数是隐含
/// 在被修改的位置里的, Elf32_Rel中加数的形式这里并不定义, 它可以依处理器架构
/// 的不痛而自行决定, 在特定处理器上如何实现, 可以指定一种固定的格式, 也可以不指定
/// 格式而依据上下文来解析
///
/// 一个重定位需要引用另外两个节, 一个是符号表, 一个是被修改节, 在重定位节中, 节头的
/// sh_info 和 sh_link成员分别指明了引用关系, 不用的目标文件中,  重定位项的r_offset
/// 成员的含义略有不同
///   1. 在重定位文件中, r_offset成员含有一个节偏移量, 也就是说, 重定位本身描述的事如何修改
///   文件中另一个节的内容, 重定位偏移量 r_offset指向了另一个节中的一个存储单元地址
///   2. 在可执行文件或者共享目标文件中,  r_offset含有的是符号定义在进程空间的虚拟地址
///   可执行文件和共享目标文件是用于运行程序而不是构建程序的, 所以对他们来说更有用的信息是运行期
///   的内存虚拟地址, 而不是某个符号定义在文件中的位置
/// 尽管对于不同类型的目标文件, r_offset的含义不同, 但其重定位的作用是不变的

/// 以下是应用于r_info的宏定义

#[macro_export]
macro_rules! ELF32_R_SYM {
    ($i: expr) => {
        (($i) >> 8)
    };
}

#[macro_export]
macro_rules! ELF32_R_TYPE {
    ($i: expr) => {
        ($i as u8)
    };
}

#[macro_export]
macro_rules! ELF32_R_INFO {
    ($s: expr, $t: expr) => {
        ((($s) << 8) + ($t as u8))
    };
}

/// 被重定位的域是一个32位的的域, 占4字节并且地址向4字节对齐, 其字节与所在体系结构下的其它双字长数据的字节序相同
/// 假定一下的计算是发生在把可从定位文件转为可执行或共享目标文件的的过程中, 原则上, 连接编辑器要把一个或多个可重定位文件合并成一个
/// 可执行或共享目标文件作为输出, 它首先需要决定如何把文件组合起来, 并定位其中的符号,然后更新符号值, 最后实现重定位, 对于可执行文件
/// 或共享目标文件的重定位过程是相似的, 不管是可执行还是共享目标文件, 重定位这个过程结果是相同的
///
/// 为了下面的描述方便, 这里定义以下几种符号
///   A: 表示用于计算重定位域值的加数
///   B: 在程序运行期, 共享目标被装入内存时的基地址, 一般来说共享目标文件在构建时基地址为0, 但在运行时则不是
///   C: 可重定位项在全局偏移表中的位置, 这里存储了此重定位在运行期间的地址,
///   G: 可重定位项在全局偏移表中的位置, 这里存储了此重定位项在运行期间的地址
///   GOT: 全局偏移表的地址
///   L: 符号的函数连接表项的所在之处, 可能是节偏移量, 或者是内存地址, 函数连接表项把函数调用定位到合适的位置
///      在构建期间, 连接编辑器创建初始的函数连接表, 在运行期间 动态连接器会修改表项
///   P: 被重定位的存储单元在节内的偏移量或者内存地址, 由r_offset计算得到
///   S: 重定位项中的某个索引值所代表的符号的值
///   
/// 一个重定位项的r_offset指定了被重定位的数据在节内偏移量或者在进程空间的虚拟地址, 重定位类型指定了哪些需要被修改以及如何计算它们的值
/// Intel架构只使用了Elf32_Rel重定位项, 被重定位的域持有重定位加数, 在任何情况下 重定位加数和计算结构的字节顺序都要保持一致

//// 下面是重定位类型定义

/// G + A
pub const R_386_GOT32: Elf32_Word = 3;
/// L + A -P
pub const R_386_PLT32: Elf32_Word = 4;

pub const R_386_COPY: usize = 4;
/// S
/// 这种重定位类型, 用于把指定的符号地址设置位一个全局偏移表项
/// 这种重定位类型在符号与全局偏移表之间建立起了联系
pub const R_386_GLOB_DATA: Elf32_Word = 6;
/// S
/// 连接编辑器创建这种重定位类型, 用于动态连接, 吃类型相应的offset成员给出了函数连接表项的位置
/// 动态连接起修改函数连接表项来跳转到指定的符号地址
pub const R_386_JMP_SLOT: Elf32_Word = 7;
/// B + A
/// 连接编辑器创建这种重定位类型，主要是用于动态连接。此类型相应的offset
/// 成员给出了共享目标内的一个位置，这个位置含有一个代表相对地址的值。把共享
/// 目标被加载的地址加上这个相对地址，动态连接器就可以计算得到真正需要的虚拟
/// 地址。这种类型的重定位项必须为符号表指定0 值
pub const R_386_RELATIVE: Elf32_Word = 8;
/// S + A - GOT
/// 这种重定位类型计算符号值与全局偏移表地址之间的差值, 它还指示连接编辑器去构建全局偏移表
pub const R_386_GOTOFF: Elf32_Word = 9;
/// GOT + A - P
/// 这种重定位类型中R_386_PC32很相似, 只不过在计算中它使用的时全局偏移表的地址, 一般来说
/// 这种类型的重定位中所引用的符号是, _GLOBAL_OFFSET_TABLE_ 它还指示连接编辑器去构建全局偏移表
pub const R_386_GOTPC: Elf32_Word = 10;

#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Rel {
    /// 本数据成员给出重定位所作用的位置, 对于重定位文件来说, 此值是受重定位作用的存储单元在节中的字节偏移量
    /// 对于可执行文件或共享目标文件来说, 此值是受重定位作用的存储单元虚拟地址
    pub r_offset: Elf32_Addr,
    /// 给出了重定位所作用的符号表索引, 也给出了重定位的类型, 比如
    /// 如果是一个函数的重定位, 本数据成员 将要持有被调用函数所对应的符号表索引, 如果索引值为STN_UNDEF 即为定义
    /// 那么重定位过程中将使用0作为符号值, 重定位类型依处理器不同而不同, 各种处理器将分别定义自己的类型
    /// 如果一种处理器规定自己引用了一个重定位项的类型或者符号表索引, 表明这种处理器应用了 ELF32_R_TYPE或ELF32_R_SYM到其重定位项的r_info成员
    pub r_info: Elf32_Word,
}

#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    /// 指定了一个加数, 这个加数用于计算重定位的域的值
    pub r_addend: Elf32_Sword,
}

/// ELF文件的装在与动态连接
/// 用于创建程序的目标文件信息和系统行为, 可执行文件的共享目标文件(动态链接库)是程序的静态存储形式, 要执行一个程序, 需要先把
/// 相应的可执行文件和动态链接转载到进程空间中, 这样形成一个可运行的进程内存空间布局,  也可以它称为 进程镜像, 一个已转载完成的
/// 进程空间会包含多个不同的段(segment), 比如代码段(text segment) 数据段(data segment) 堆栈段(stack segment)等等

/// 程序头
/// 一个可执行文件或共享目标文件的程序头, (program header table) 是一个数组, 数组中的每一个元素成为 程序头 (program header)
/// 每一个程序头描述了一个段(segment) 或者一块用于执行程序的信息, 一个目标文件中的 段(segment) 包含一个或多个 节(section) 程序头
/// 只对可执行文件或者共享目标文件有意义, 对于其它类型的目标文件, 该信息可以忽略, 在目标文件的文件头 (elf header)中
/// e_phentsize e_phnum中指定了程序头的大小

/// 下面是 p_type 字段值相关定义

/// 本程序头内的其它成员值均无意义
pub const PT_NULL: Elf32_Word = 0;
/// 指向一个可装载的的段, 段的内容会被从文件中拷贝到内存中
/// 段在文件中的大小是p_filesz, 在内存中的大小是p_memsz 如前所述 段在文件中的大小是p_filesz, 在内存中的大小是
/// p_memsz 如果p_memsz大于p_filesz 在内存中多出的存储空间应该填0补充, 也就是说, 段在内存中可以比在文件中占用的空间更大
/// 而相反, p_filesz永远不应该比p_memsz大, 因为这样的话 内存中就将无法完整映射段的内容, 在程序头表中, 所有PT_LOAD类型的程序头
/// 按照p_vaddr的值做升序排列
pub const PT_LOAD: Elf32_Word = 1;
/// 本段指明了动态连接信息
pub const PT_DYNAMIC: Elf32_Word = 2;
/// 本段指向了一个null结尾的字符串, 这个字符串是一个ELF解析器路径,
/// 这种段类型只对可执行程序有意义, 当它出现在共享目标文件时 是一个无意义的多余项, 在一个ELF文件中
/// 它最多只能出现一次, 而起必须出现在其它可装载的表项之前
pub const PT_INTERP: Elf32_Word = 3;
/// 本段指向了一个以 null结尾的字符串, 这个字符串包含一些附加的信息
pub const PT_NOTE: Elf32_Word = 4;
/// 该段类型是保留的, 而起未定义语法, UNIX System V 系统上的应用不会包含这种表项
pub const PT_SHLIB: Elf32_Word = 5;
/// 此类型的程序头如果存在, 它表明的是其自身所在程序头标在文件或内存中的位置和大小, 这样的段在文件中可以不存在
/// 只有当所在程序头表覆盖的段只是整个程序的一部分时, 才会出现一次这种表项, 而起这种表项一定出现在其它可装载段的表项之前
pub const PT_PHDR: Elf32_Word = 6;

/// PT_LOPROC ~ PT_HIPROC 类型值在这个区间的程序头是为特定处理器保留的。
pub const PT_LOPROC: Elf32_Word = 0x70000000;
pub const PT_HIPROC: Elf32_Word = 0x7fffffff;

#[repr(C)]
#[derive(Debug)]
pub struct Elf32_Phdr {
    /// 此数据成员说明了本程序头描述的段类型, 或者如何解析本程序头信息
    pub p_type: Elf32_Word,
    /// 此数据成员给出本段内容在文件中的位置, 即段内容开始位置相对于文件开头的偏移量
    pub p_offset: Elf32_Off,
    /// 此数据成员给出本段内容开始位置在进程地址空间中的虚拟地址
    pub p_vaddr: Elf32_Addr,
    /// 此数据成员给出本段内容的开始位置在进程空间中的物理地址, 对于目前大多数现代操作系统而言, 应用程序中的物理地址事先是不可知的
    /// 所以目前这个成员多数情况下保留不用, 或者被操作系统改作它用
    pub p_paddr: Elf32_Addr,
    /// 此数据成员给出本段内容在文件中的大小, 单位是字节, 可以是0
    pub p_filesz: Elf32_Addr,
    /// 此数据成员给出本段内容在内容镜像中的大小, 单位是字节 可以是0
    pub p_memsz: Elf32_Word,
    /// 此数据成员给出了本段内容的属性
    pub p_flags: Elf32_Word,
    /// 对于可装载的段来说, 其p_vaddr和p_offset的值至少要向内存页面大小对齐
    /// 此数据成员指明本段内容如何在内存和文件中对齐, 如果该值为0或1, 表明没有对齐要求
    /// 否则 p_align应该是一个正整数, 并且是2的幂次数, p_vaddr和p_offset在对p_align取模
    /// 后应该相等
    pub p_align: Elf32_Word,
}

/// 基地址
/// 程序头中出想的虚拟地址不能代表其相对应的数据在进程内存空间的虚拟地址, 可执行文件中需要含有绝对的地址
/// 比如变量地址, 函数地址等, 为了让程序正确的执行, 段中出现的虚拟地址必须在创建可执行程序时重新计算, 另一方面
/// 出于ELF通用性要求, 即同一个段在被加载到两个不同的进程中时, 它的地址可能不同, 但它的行为不能表现处不一样
///
/// 在被加载到进程空间时, 尽管段会被分配到一个不确定的地址, 但是不同的段之间会有确定 相对位置, 也就是说, 在目标文件中
/// 存储的两个段, 它们的位置之间有多少偏移, 当它们被加载到内存中时, 这两个段的位置之间仍然保持这么大的偏移(距离), 一个段
/// 在内存中的虚拟地址与其在目标文件中的地址一般是不想等的, 它们之间会有一个偏移量, 这个偏移量被称为基地值(base address)
/// 基地值的作用之一就是在动态连接过程中为程序重定位内存镜像
///
/// 一个可执行文件或共享目标文件的基地值是在运行期间由以下三个值计算出来的, 内存加载地址, 最大页面大小, 程序可装载段的最低地址
/// 为计算基地值, 首先找出类型为PT_LOAD(即可加载) 而起p_vaddr(段地址)最低的那个段, 把这个段在内存中的地址与最大页面大小相除
/// 得到一个段地址的余数, 再把p_vaddr与最大页面大小相除, 得到一个p_vaddr的余数, 基地值就是这个段地址的余数与p_vaddr的余数之差
///
///
/// 段权限
/// 虽然ELF文件格式中没有规定, 但是一个可执行程序至少会有一个可加载的段, 当为可执行段创建内存镜像时, 系统会按照p_flags的指示给段赋予一定的权限

/// 被PF_MASKPROC所覆盖的权限值是为特殊处理器保留的, 处理器可以按照自己的定义来解析它
///
/// 如果权限值为0, 表示它无任何权限, 实际的读写权限还要依赖于内存管理器, 在不同的操作系统上
/// 内存管理单元的做法可能会不同, 在有些组合方式下, 系统给出的权限会被所指定的权限大, 但可写权限PF_W除外
/// 如果p_flags中没有指定PF_W 系统一定不会给出写权限

/// 可执行
pub const PF_X: Elf32_Word = 0x1;
/// 只写
pub const PF_W: Elf32_Word = 0x2;
/// 只读
pub const PF_R: Elf32_Word = 0x4;
/// 未指定
pub const PF_MASKPROC: Elf32_Word = 0xf0000000;

/// 动态连接器
/// 当创建一个可执行文件时, 如果依赖其它的动态连接库, 那么链接编辑器会在可执行文件的程序头加入一个PT_INTERP项
/// 告诉系统这里需要使用动态连接器
///
/// 可执行文件与动态连接器一起创建了进程的镜像, 这个过程包含以下活动
///     1. 添加可执行文件的段到进程空间
///     2. 添加共享目标文件的段到进程空间
///     3. 为可执行文件和共享目标文件进行重定位
///     4. 如果动态连接器使用了可执行文件的文件描述符, 应该关闭它
///     5. 把控制权交给程序
///     连接器也会为动态连接器组织一些数据, 以方便它连接的过程, 在程序头部分提到过, 为了方便在运行时候访问, 这些数据放在可装载的段中
///     当然具体数据格式是依处理器而不同的
///     6. 类型为SHT_DYNAMIC的.dynamic节中包含有很多动态连接信息, 在这个节的最开始处有一个结构, 其中包含有其它动态连接信息的地址
///     类型为SHT_HASH的.hash表中含有符号哈希表
///     类型为SHT_PROGBITS的.got和.plt节各包含一张表, GOT是 global offset table 的缩写, 即全局偏移表
///     用于位置独立的代码, plt是procedure linkage table 的缩写, 译为函数连接表
/// 因为每个与UNIX System V 兼容的程序都会从一个共享目标库中导入系统调用, 所以在每个与TIS ELF格式一致的程序执行时, 动态连接器都会起作用
///
/// 回想程序装载 部分所描述过的, 共享目标所占据的内存地址可能与文件程序表头中所记录的不同, 在程序开始执行前, 动态连接器会为内存镜像做重定位, 更新绝对地址
/// 当然, 库文件被装载时, 如果其内存地址与文件描述的完全相同的话, 那些引用它们的绝对地址就是对的, 不需要更新, 但事实上, 这种情况很少发生
///
/// 如果进程的环境表量中含有LD_BIND_NOW 而其值不为空, 那么动态连接器就要在程序开始运行前把所有重定位都处理完, 比如, 在该环境变量为一下值时
/// 动态连接器都需要这样做
///     LD_BIND_NOW=1
///     LD_BIND_NOW=on
///     LD_BIND_NOW=off
/// 否则, 如果LB_BIND_NOW没有出现或者其值为空, 动态连接就可以把处理定位的工作推后, 即只有当一个符号被引用的时候才去重定位它, 因为程序运行过程中, 有一些函数
/// 并不会被调用到, 推后重定位是一种搞笑的方法,可以避免为这些函数做不必要的重定位
///
///
/// 动态段
/// 如果一个目标文件参与动态连接的话, 它的程序头表一定会包含一个类型会PT_DYNAMIC的表项, 其所对应的段称为动态段, 段的名字为.dynamic 动态段的作用是
/// 提供动态连接器所需要的信息, 比如依赖哪些共享目标文件, 动态连接符号的位置, 动态连接重定位表的位置等等
///
/// 这个动态段中包含有动态节, 动态节由符号_DYNAMIC所标记 它包含一个由如下结构体组成的数组

/// 下面列出了可执行文件或共享目标文件所要求的标记 (d_tag) 如果一个标记被置为必须, 那么在ELF文件的动态连接数组中就必须包含一个此类型的项
/// 如果被设置为可选, 那就不是必须的, 可有可无

/// d_un  可执行文件  共享文件      值
/// 忽略     必须      必须
/// 用于标记_DYNAMIC数组的结束
pub const DT_NULL: Elf32_Sword = 0;
/// d_val   可选      可选
/// 此元素指明了一个所需库的名字, 不过此元素本身并不是一个字符串
/// 它是一个指向由DT_STRTABLE所标记的字符串中的索引
/// 在动态数组中可以包含若干个此类型的项, 这些项出现的相对顺序是不能随意调换的
pub const DT_NEEDED: Elf32_Sword = 1;
/// d_val   可选      可选
/// 含有与函数连接表相关的所有重定位项的总大小, 以字节为单位, 如果数组中有DT_JMPREL项的话
/// DT_PLTRELSZ也必须要有
pub const DT_PLTRELSZ: Elf32_Sword = 2;
/// d_ptr   可选      可选
/// 包含与函数连接表或全局偏移表相应的地址, 在Intel架构中, 这一项d_ptr成员给出全局偏移表中第一项的地址
/// 如下文所述, 全局偏移表中前三项都是保留的, 其中两项用于持有函数连接表信息
pub const DT_PLTGOT: Elf32_Sword = 3;
/// d_ptr   必须      必须
/// 含有哈希表的地址, 这里所指的哈希表与DT_SYMTAB所指的哈希表是同一个
pub const DT_HASH: Elf32_Sword = 4;
/// d_ptr   必须      必须
/// 此元素包含字符串表的地址, 此表包含符号名, 库名等
pub const DT_STRTAB: Elf32_Sword = 5;
/// d_ptr   必须      必须
/// 此元素包含符号表地址
pub const DT_SYMTAB: Elf32_Sword = 6;
/// d_ptr   必须      可选
/// 此元素包含一个重定位表的地址, 在重定位表中存储的是显式的 加数 比如对于32位文件来说, 这种加数就是Elf32_Rela 在目标文件中可以存在多个重定位节
/// 当为可执行文件或共享目标文件创建重定位表的时候, 连接编辑器会把这些重定位节连接在一起, 最后形成一张大的重定位表, 当连接编辑器为一个可执行文件创建进行空间
/// 或者把一个共享目标添加到进程空间中去的时候, 它会去读重定位表并执行相应的操作, 如果在动态结构中包含有DT_RELA元素的话, 就必须同时还含DT_RELASZ和DT_ELEANT元素
/// 如果一个文件需要重定位的话, DT_RELA或DT_REL至少要出现一个
pub const DT_RELA: Elf32_Sword = 7;
/// d_val   必须      可选
/// 此元素持有DT_RELA相应的重定位表的大小, 以字节为单位
pub const DT_RELASZ: Elf32_Sword = 8;
/// d_val   必须      可选
/// 此元素持有DT_RELA相应重定位表项的大小
pub const DT_RELAENT: Elf32_Sword = 9;
/// d_val   必须      必须
/// 此元素持有字符串表的大小, 以字节为单位
pub const DT_STRSZ: Elf32_Sword = 10;
/// d_val   必须      必须
/// 此元素持有符号表项的大小
pub const DT_SYMENT: Elf32_Sword = 11;
/// d_val   可选      可选
/// 持有初始化函数的地址
pub const DT_INIT: Elf32_Sword = 12;
/// d_ptr   可选      可选
/// 持有终止函数的地址
pub const DT_FINI: Elf32_Sword = 13;
/// d_val   忽略      可选
/// 持有一个字符串表中的偏移量, 是一个共享目标的名字, 相应的字符串表由DT_STRTAB指定
pub const DT_SONAME: Elf32_Sword = 14;
/// d_val   可选      忽略   
/// 持有一个字符串表中的偏移, 是一个用于搜索库文件路径名, 相应的字符串表由DT_STRTAB指定
pub const DT_RPATH: Elf32_Sword = 15;
/// 忽略     忽略      可选
/// 在共享目标中, 此元素的出现与否决定了动态连接器解析符号时所用的算法, 如果此元素不出的话, 动态连接器先搜索可执行文件, 在搜索库文件
/// 如果此元素出的话, 顺序刚好相反, 动态连接器会先从本共享目标文件开始, 后搜索执行文件
pub const DT_SYMBOLIC: Elf32_Sword = 16;
/// d_ptr   必须      可选
/// 此元素与DT_RELA相似, 只是它执行的重定位表中, 加数 是隐含而不是显式的
pub const DT_REL: Elf32_Sword = 17;
/// d_val   必须      可选 
/// 此元素持有DT_REL相应重定位表的大小, 以字节为单位
pub const DT_RELSZ: Elf32_Sword = 18;
/// d_val   必须      可选
/// 此元素持有DT_REL相应重定位表项的大小, 以字节为单位
pub const DT_RELENT: Elf32_Sword = 19;
/// d_val   可选      可选
/// 指明了函数连接表所引用的重定位项的类型, d_val成员含有DT_REL或DT_RELA 函数连接表中所有重定位类型都是相同的
pub const DT_PLTREL: Elf32_Sword = 20;
/// d_val   可选      忽略
/// 用于调试, 格式未明确定义
pub const DT_DEBUG: Elf32_Sword = 21;
/// 忽略     可选      可选
/// 如果此元素出的话, 在重定位过程中, 如果需要修改的是只读段的话, 连接编辑器可以做相应的修改
/// 而如果此元素不出的话, 在重定位过程中, 即使需要, 也不能修改只读段
pub const DT_TEXTREL: Elf32_Sword = 22;
/// d_ptr   可选      可选
/// 此类型元素如果存在的话, 其d_ptr成员含有与函数连接表单独关联的重定位项地址, 把多个重定位项分开可以让动态连接器在初始化的时候忽略它们
/// 当然前提条件是, 后期绑定是激活的, 如果此元素存在的话, DT_PLTRELSZ和DT_PLTREL也应该出现
pub const DT_JMPREL: Elf32_Sword = 23;
/// 忽略     可选      可选
/// 如果此元素存在的话, 动态连接器必须在程序开始执行以前, 完成所有包含此项目标的重定位工作, 
/// 如果此元素存在, 即使程序应用了后期绑定, 它对于此项所指定的目标也不适用, 动态连接器仍需做好重定位
pub const DT_BIND_NOW: Elf32_Sword = 24;
/// 未定义   未定义     未定义
/// DT_LOPROC ~ DT_HIPROC: 这一区间的值是为处理器保留的。
pub const DT_LOPROC: Elf32_Sword = 0x70000000;
/// 未定义   未定义     未定义
pub const DT_HIPROC: Elf32_Sword = 0x7fffffff;
/// 以上各种类型元素中, 除了DT_NULL必须出现在数组结尾, DT_NEEDED有相对顺序要求以外
/// 其它所有元素出现的顺序都没有限制
/// 在上表中没有出现的标记值都是保留未用的



#[repr(C)]
pub union Elf32_Dyn_Union {
    /// 类型为Elf32_Word的目标代表的是整形数
    pub d_val: Elf32_Word,
    /// 类型为Elf32_Addr的目标项代表的是进程空间的地址, 前面描述过, 目标项在文件中的地址与其在进程空间内的地址可能会不同
    /// 当系统解析道这个动态节的地址时, 动态连接器就可以根据文件地址和内存基址来计算实际的内存地址, 为了保持一致, 文件中不会包含重定位
    /// 项来校正动态结构中的地址
    pub d_ptr: Elf32_Addr,
}

#[repr(C)]
pub struct Elf32_Dyn {
    /// 对于每个这种类型的目标项, d_tag控制着对d_un的解析
    pub d_tag: Elf32_Sword,
    /// .
    pub d_un: Elf32_Dyn_Union,
}
